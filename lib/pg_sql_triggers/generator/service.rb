# frozen_string_literal: true

require "fileutils"
require "digest"
require "active_support/core_ext/string/inflections"

module PgSqlTriggers
  module Generator
    # Service object for generating trigger DSL files, migration files, and registering triggers.
    #
    # This service follows the service object pattern with class methods for stateless operations.
    #
    # @example Generate trigger files
    #   form = PgSqlTriggers::Generator::Form.new(trigger_name: "users_email_validation", ...)
    #   result = PgSqlTriggers::Generator::Service.create_trigger(form, actor: current_user)
    #
    #   if result[:success]
    #     puts "Created: #{result[:migration_path]}"
    #   end
    # rubocop:disable Metrics/ClassLength
    class Service
      class << self
        # Generates the DSL trigger definition code from a form.
        #
        # @param form [PgSqlTriggers::Generator::Form] The form containing trigger parameters
        # @return [String] The generated DSL code
        def generate_dsl(form)
          # Generate DSL trigger definition
          events_list = form.events.compact_blank.map { |e| ":#{e}" }.join(", ")
          environments_list = form.environments.compact_blank.map { |e| ":#{e}" }.join(", ")

          # Format function name (can be string or symbol)
          function_ref = if form.function_name.to_s.match?(/\A[a-z0-9_]+\z/)
                           ":#{form.function_name}"
                         else
                           "\"#{form.function_name}\""
                         end

          code = <<~RUBY
            # frozen_string_literal: true

            # Generated by pg_sql_triggers on #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}
            PgSqlTriggers::DSL.pg_sql_trigger "#{form.trigger_name}" do
              table :#{form.table_name}
              on #{events_list}
              function #{function_ref}
            #{'  '}
              version #{form.version}
              enabled #{form.enabled}
              timing :#{form.timing || 'before'}
          RUBY

          code += "  when_env #{environments_list}\n" if form.environments.compact_blank.any?

          code += "  when_condition \"#{form.condition.gsub('"', '\\"')}\"\n" if form.condition.present?

          code += "end\n"

          code
        end

        # Generates the migration file code from a form.
        #
        # @param form [PgSqlTriggers::Generator::Form] The form containing trigger parameters
        # @return [String] The generated migration code
        def generate_migration(form)
          # Generate migration class code
          # Use Rails migration naming convention: Add{TriggerName}
          # This avoids Zeitwerk autoload conflicts with app/triggers files
          class_name = "Add#{form.trigger_name.camelize}"
          events_sql = form.events.compact_blank.map(&:upcase).join(" OR ")
          function_body_sql = form.function_body.strip

          # Build the trigger creation SQL
          timing_value = (form.timing || "before").upcase
          trigger_sql = "CREATE TRIGGER #{form.trigger_name}\n"
          trigger_sql += "#{timing_value} #{events_sql} ON #{form.table_name}\n"
          trigger_sql += "FOR EACH ROW\n"
          trigger_sql += "WHEN (#{form.condition})\n" if form.condition.present?
          trigger_sql += "EXECUTE FUNCTION #{form.function_name}();"

          # Build the down method SQL
          down_sql = "DROP TRIGGER IF EXISTS #{form.trigger_name} ON #{form.table_name};\n"
          down_sql += "DROP FUNCTION IF EXISTS #{form.function_name}();"

          # Indent SQL strings to match heredoc indentation (18 spaces)
          indented_function_body = indent_sql(function_body_sql, 18)
          indented_trigger_sql = indent_sql(trigger_sql, 18)
          indented_down_sql = indent_sql(down_sql, 18)

          <<~RUBY
            # frozen_string_literal: true

            # Generated by pg_sql_triggers on #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}
            class #{class_name} < PgSqlTriggers::Migration
              def up
                # Create the function
                execute <<-SQL
                  #{indented_function_body}
                SQL

                # Create the trigger
                execute <<-SQL
                  #{indented_trigger_sql}
                SQL
              end

              def down
                execute <<-SQL
                  #{indented_down_sql}
                SQL
              end
            end
          RUBY
        end

        # Generates a PL/pgSQL function stub template.
        #
        # @param form [PgSqlTriggers::Generator::Form] The form containing trigger parameters
        # @return [String, nil] The generated function stub SQL, or nil if not requested
        def generate_function_stub(form)
          return nil unless form.generate_function_stub

          # Generate PL/pgSQL function template
          events_display = form.events.compact_blank.join(", ").upcase

          <<~SQL
            -- PL/pgSQL function for trigger: #{form.trigger_name}
            -- Table: #{form.table_name}
            -- Events: #{events_display}
            -- Generated by pg_sql_triggers on #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}
            --
            -- TODO: Implement your trigger logic below

            CREATE OR REPLACE FUNCTION #{form.function_name}()
            RETURNS TRIGGER AS $$
            BEGIN
              -- Access OLD record: OLD.column_name (for UPDATE, DELETE)
              -- Access NEW record: NEW.column_name (for INSERT, UPDATE)

              -- Example: Validate a field
              -- IF NEW.some_field > threshold THEN
              --   RAISE EXCEPTION 'Validation failed: %', NEW.some_field;
              -- END IF;

              -- TODO: Add your validation/business logic here
              RAISE NOTICE 'Trigger function % called for %', TG_NAME, TG_OP;

              -- For INSERT/UPDATE triggers, return NEW
              -- For DELETE triggers, return OLD
              -- For TRUNCATE triggers, return NULL
              IF TG_OP = 'DELETE' THEN
                RETURN OLD;
              ELSIF TG_OP = 'TRUNCATE' THEN
                RETURN NULL;
              ELSE
                RETURN NEW;
              END IF;
            END;
            $$ LANGUAGE plpgsql;
          SQL
        end

        # Returns the file paths where the migration and DSL files will be created.
        #
        # @param form [PgSqlTriggers::Generator::Form] The form containing trigger parameters
        # @return [Hash] Hash with :migration and :dsl keys containing relative file paths
        def file_paths(form)
          # NOTE: These paths are relative to the host Rails app, not the gem
          # Generate both migration file and DSL file
          migration_version = next_migration_number
          {
            migration: "db/triggers/#{migration_version}_#{form.trigger_name}.rb",
            dsl: "app/triggers/#{form.trigger_name}.rb"
          }
        end

        # Creates trigger files (DSL and migration) and registers the trigger in the registry.
        #
        # @param form [PgSqlTriggers::Generator::Form] The form containing trigger parameters
        # @param actor [Hash, nil] Optional actor information for audit logging
        # @return [Hash] Result hash with :success (Boolean), :migration_path, :dsl_path, and optional :error
        def create_trigger(form, actor: nil) # rubocop:disable Lint/UnusedMethodArgument
          paths = file_paths(form)
          base_path = rails_base_path

          create_trigger_files(form, paths, base_path)
          registry = register_trigger(form)

          build_success_response(registry, paths, form)
        rescue StandardError => e
          log_error(e)
          build_error_response(e)
        end

        private

        def indent_sql(sql_string, indent_level)
          indent = " " * indent_level
          sql_string.lines.map do |line|
            stripped = line.chomp
            stripped.empty? ? "" : indent + stripped
          end.join("\n")
        end

        def rails_base_path
          defined?(Rails) && Rails.respond_to?(:root) ? Rails.root : Pathname.new(Dir.pwd)
        end

        def create_trigger_files(form, paths, base_path)
          full_migration_path = base_path.join(paths[:migration])
          full_dsl_path = base_path.join(paths[:dsl])

          FileUtils.mkdir_p(full_migration_path.dirname)
          FileUtils.mkdir_p(full_dsl_path.dirname)

          migration_content = generate_migration(form)
          dsl_content = generate_dsl(form)

          File.write(full_migration_path, migration_content)
          File.write(full_dsl_path, dsl_content)
        end

        def register_trigger(form)
          definition = build_trigger_definition(form)
          attributes = build_registry_attributes(form, definition)
          TriggerRegistry.create!(attributes)
        end

        def build_trigger_definition(form)
          {
            name: form.trigger_name,
            table_name: form.table_name,
            events: form.events.compact_blank,
            function_name: form.function_name,
            version: form.version,
            enabled: form.enabled,
            environments: form.environments.compact_blank,
            condition: form.condition,
            timing: form.timing || "before",
            function_body: form.function_body
          }
        end

        def build_registry_attributes(form, definition)
          attributes = {
            trigger_name: form.trigger_name,
            table_name: form.table_name,
            version: form.version,
            enabled: form.enabled,
            source: "dsl",
            environment: form.environments.compact_blank.join(",").presence,
            definition: definition.to_json,
            function_body: form.function_body,
            checksum: calculate_checksum(definition)
          }

          add_conditional_attributes(attributes, form)
          attributes
        end

        def add_conditional_attributes(attributes, form)
          column_names = TriggerRegistry.column_names

          attributes[:condition] = form.condition.presence if column_names.include?("condition")
          attributes[:timing] = (form.timing || "before") if column_names.include?("timing")
        end

        def build_success_response(registry, paths, form)
          {
            success: true,
            registry_id: registry.id,
            migration_path: paths[:migration],
            dsl_path: paths[:dsl],
            metadata: {
              trigger_name: form.trigger_name,
              table_name: form.table_name,
              events: form.events.compact_blank,
              files_created: [paths[:migration], paths[:dsl]]
            }
          }
        end

        def log_error(error)
          return unless defined?(Rails)

          Rails.logger.error("Trigger generation failed: #{error.message}")
          Rails.logger.error(error.backtrace.join("\n"))
        end

        def build_error_response(error)
          {
            success: false,
            error: error.message
          }
        end

        def next_migration_number
          # Determine if we're in a Rails app context or standalone gem
          base_path = defined?(Rails) && Rails.respond_to?(:root) ? Rails.root : Pathname.new(Dir.pwd)
          triggers_path = base_path.join("db", "triggers")

          # Get the highest migration number from existing migrations
          existing = if Dir.exist?(triggers_path)
                       Dir.glob(triggers_path.join("*.rb"))
                          .map { |f| File.basename(f, ".rb").split("_").first.to_i }
                          .reject(&:zero?)
                          .max || 0
                     else
                       0
                     end

          # Generate next timestamp-based version
          # Format: YYYYMMDDHHMMSS
          now = Time.now.utc
          base = now.strftime("%Y%m%d%H%M%S").to_i

          # If we have existing migrations, ensure we're incrementing
          base = existing + 1 if existing.positive? && base <= existing

          base
        end

        def calculate_checksum(definition)
          # Use field-concatenation algorithm (consistent with TriggerRegistry#calculate_checksum)
          Digest::SHA256.hexdigest([
            definition[:name],
            definition[:table_name],
            definition[:version],
            definition[:function_body] || "",
            definition[:condition] || "",
            definition[:timing] || "before"
          ].join)
        end
      end
    end
    # rubocop:enable Metrics/ClassLength
  end
end
