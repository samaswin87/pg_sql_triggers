# frozen_string_literal: true

require "fileutils"
require "digest"
require "active_support/core_ext/string/inflections"

module PgSqlTriggers
  module Generator
    class Service
      class << self
        def generate_dsl(form)
          # Generate DSL trigger definition
          events_list = form.events.compact_blank.map { |e| ":#{e}" }.join(", ")
          environments_list = form.environments.compact_blank.map { |e| ":#{e}" }.join(", ")

          # Format function name (can be string or symbol)
          function_ref = if form.function_name.to_s.match?(/\A[a-z0-9_]+\z/)
                           ":#{form.function_name}"
                         else
                           "\"#{form.function_name}\""
                         end

          code = <<~RUBY
            # frozen_string_literal: true

            # Generated by pg_sql_triggers on #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}
            PgSqlTriggers::DSL.pg_sql_trigger "#{form.trigger_name}" do
              table :#{form.table_name}
              on #{events_list}
              function #{function_ref}
            #{'  '}
              version #{form.version}
              enabled #{form.enabled}
          RUBY

          code += "  when_env #{environments_list}\n" if form.environments.compact_blank.any?

          code += "  when_condition \"#{form.condition.gsub('"', '\\"')}\"\n" if form.condition.present?

          code += "end\n"

          code
        end

        def generate_migration(form)
          # Generate migration class code
          # Use Rails migration naming convention: Add{TriggerName}
          # This avoids Zeitwerk autoload conflicts with app/triggers files
          class_name = "Add#{form.trigger_name.camelize}"
          events_sql = form.events.compact_blank.map(&:upcase).join(" OR ")
          function_body_sql = form.function_body.strip

          # Build the trigger creation SQL
          trigger_sql = "CREATE TRIGGER #{form.trigger_name}\n"
          trigger_sql += "BEFORE #{events_sql} ON #{form.table_name}\n"
          trigger_sql += "FOR EACH ROW\n"
          trigger_sql += "WHEN (#{form.condition})\n" if form.condition.present?
          trigger_sql += "EXECUTE FUNCTION #{form.function_name}();"

          # Build the down method SQL
          down_sql = "DROP TRIGGER IF EXISTS #{form.trigger_name} ON #{form.table_name};\n"
          down_sql += "DROP FUNCTION IF EXISTS #{form.function_name}();"

          <<~RUBY
            # frozen_string_literal: true

            # Generated by pg_sql_triggers on #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}
            class #{class_name} < PgSqlTriggers::Migration
              def up
                # Create the function
                execute <<-SQL
                  #{function_body_sql}
                SQL

                # Create the trigger
                execute <<-SQL
                  #{trigger_sql}
                SQL
              end

              def down
                execute <<-SQL
                  #{down_sql}
                SQL
              end
            end
          RUBY
        end

        def generate_function_stub(form)
          return nil unless form.generate_function_stub

          # Generate PL/pgSQL function template
          events_display = form.events.compact_blank.join(", ").upcase

          <<~SQL
            -- PL/pgSQL function for trigger: #{form.trigger_name}
            -- Table: #{form.table_name}
            -- Events: #{events_display}
            -- Generated by pg_sql_triggers on #{Time.current.strftime('%Y-%m-%d %H:%M:%S')}
            --
            -- TODO: Implement your trigger logic below

            CREATE OR REPLACE FUNCTION #{form.function_name}()
            RETURNS TRIGGER AS $$
            BEGIN
              -- Access OLD record: OLD.column_name (for UPDATE, DELETE)
              -- Access NEW record: NEW.column_name (for INSERT, UPDATE)

              -- Example: Validate a field
              -- IF NEW.some_field > threshold THEN
              --   RAISE EXCEPTION 'Validation failed: %', NEW.some_field;
              -- END IF;

              -- TODO: Add your validation/business logic here
              RAISE NOTICE 'Trigger function % called for %', TG_NAME, TG_OP;

              -- For INSERT/UPDATE triggers, return NEW
              -- For DELETE triggers, return OLD
              -- For TRUNCATE triggers, return NULL
              IF TG_OP = 'DELETE' THEN
                RETURN OLD;
              ELSIF TG_OP = 'TRUNCATE' THEN
                RETURN NULL;
              ELSE
                RETURN NEW;
              END IF;
            END;
            $$ LANGUAGE plpgsql;
          SQL
        end

        def file_paths(form)
          # NOTE: These paths are relative to the host Rails app, not the gem
          # Generate both migration file and DSL file
          migration_version = next_migration_number
          {
            migration: "db/triggers/#{migration_version}_#{form.trigger_name}.rb",
            dsl: "app/triggers/#{form.trigger_name}.rb"
          }
        end

        def create_trigger(form, _actor: nil)
          paths = file_paths(form)

          # Determine if we're in a Rails app context or standalone gem
          base_path = defined?(Rails) && Rails.respond_to?(:root) ? Rails.root : Pathname.new(Dir.pwd)

          full_migration_path = base_path.join(paths[:migration])
          full_dsl_path = base_path.join(paths[:dsl])

          # Create directories
          FileUtils.mkdir_p(full_migration_path.dirname)
          FileUtils.mkdir_p(full_dsl_path.dirname)

          # Generate content
          migration_content = generate_migration(form)
          dsl_content = generate_dsl(form)
          # Use function_body (required field)
          function_content = form.function_body

          # Write both files
          File.write(full_migration_path, migration_content)
          File.write(full_dsl_path, dsl_content)

          # Register in TriggerRegistry
          definition = {
            name: form.trigger_name,
            table_name: form.table_name,
            events: form.events.compact_blank,
            function_name: form.function_name,
            version: form.version,
            enabled: form.enabled,
            environments: form.environments.compact_blank,
            condition: form.condition
          }

          attributes = {
            trigger_name: form.trigger_name,
            table_name: form.table_name,
            version: form.version,
            enabled: form.enabled,
            source: "dsl",
            environment: form.environments.compact_blank.join(",").presence,
            definition: definition.to_json,
            function_body: function_content,
            checksum: calculate_checksum(definition)
          }

          # Only include condition if the column exists and value is present
          attributes[:condition] = form.condition.presence if TriggerRegistry.column_names.include?("condition")

          registry = TriggerRegistry.create!(attributes)

          {
            success: true,
            registry_id: registry.id,
            migration_path: paths[:migration],
            dsl_path: paths[:dsl],
            metadata: {
              trigger_name: form.trigger_name,
              table_name: form.table_name,
              events: form.events.compact_blank,
              files_created: [paths[:migration], paths[:dsl]]
            }
          }
        rescue StandardError => e
          Rails.logger.error("Trigger generation failed: #{e.message}") if defined?(Rails)
          Rails.logger.error(e.backtrace.join("\n")) if defined?(Rails)

          {
            success: false,
            error: e.message
          }
        end

        private

        def next_migration_number
          # Determine if we're in a Rails app context or standalone gem
          base_path = defined?(Rails) && Rails.respond_to?(:root) ? Rails.root : Pathname.new(Dir.pwd)
          triggers_path = base_path.join("db", "triggers")

          # Get the highest migration number from existing migrations
          existing = if Dir.exist?(triggers_path)
                       Dir.glob(triggers_path.join("*.rb"))
                          .map { |f| File.basename(f, ".rb").split("_").first.to_i }
                          .reject(&:zero?)
                          .max || 0
                     else
                       0
                     end

          # Generate next timestamp-based version
          # Format: YYYYMMDDHHMMSS
          now = Time.now.utc
          base = now.strftime("%Y%m%d%H%M%S").to_i

          # If we have existing migrations, ensure we're incrementing
          base = existing + 1 if existing.positive? && base <= existing

          base
        end

        def calculate_checksum(definition)
          Digest::SHA256.hexdigest(definition.to_json)
        end
      end
    end
  end
end
