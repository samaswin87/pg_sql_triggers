# frozen_string_literal: true

require "fileutils"
require "digest"

module PgTriggers
  module Generator
    class Service
      class << self
        def generate_dsl(form)
          # Generate the DSL Ruby code as string
          events_str = form.events.reject(&:blank?).map { |e| ":#{e}" }.join(", ")
          envs_str = form.environments.reject(&:blank?).any? ? form.environments.reject(&:blank?).map { |e| ":#{e}" }.join(", ") : nil

          code = <<~RUBY
            # frozen_string_literal: true
            # Generated by pg_triggers on #{Time.current.strftime("%Y-%m-%d %H:%M:%S")}
            # Source: generated

            PgTriggers::DSL.pg_trigger "#{form.trigger_name}" do
              table :#{form.table_name}
              on #{events_str}
              function :#{form.function_name}

              version #{form.version}
              enabled #{form.enabled}
          RUBY

          code += "  when_env #{envs_str}\n" if envs_str
          code += "  when_condition \"#{form.condition}\"\n" if form.condition.present?
          code += "end\n"

          code
        end

        def generate_function_stub(form)
          return nil unless form.generate_function_stub

          # Generate PL/pgSQL function template
          events_display = form.events.reject(&:blank?).join(", ").upcase

          <<~SQL
            -- PL/pgSQL function for trigger: #{form.trigger_name}
            -- Table: #{form.table_name}
            -- Events: #{events_display}
            -- Generated by pg_triggers on #{Time.current.strftime("%Y-%m-%d %H:%M:%S")}
            --
            -- TODO: Implement your trigger logic below

            CREATE OR REPLACE FUNCTION #{form.function_name}()
            RETURNS TRIGGER AS $$
            BEGIN
              -- Access OLD record: OLD.column_name (for UPDATE, DELETE)
              -- Access NEW record: NEW.column_name (for INSERT, UPDATE)

              -- Example: Validate a field
              -- IF NEW.some_field > threshold THEN
              --   RAISE EXCEPTION 'Validation failed: %', NEW.some_field;
              -- END IF;

              -- TODO: Add your validation/business logic here
              RAISE NOTICE 'Trigger function % called for %', TG_NAME, TG_OP;

              -- For INSERT/UPDATE triggers, return NEW
              -- For DELETE triggers, return OLD
              -- For TRUNCATE triggers, return NULL
              IF TG_OP = 'DELETE' THEN
                RETURN OLD;
              ELSIF TG_OP = 'TRUNCATE' THEN
                RETURN NULL;
              ELSE
                RETURN NEW;
              END IF;
            END;
            $$ LANGUAGE plpgsql;
          SQL
        end

        def file_paths(form)
          # Note: These paths are relative to the host Rails app, not the gem
          # Function body is required, so always create function file
          {
            dsl: "db/triggers/#{form.trigger_name}.rb",
            function: "db/triggers/functions/#{form.function_name}.sql"
          }
        end

        def create_trigger(form, actor:)
          paths = file_paths(form)

          # Determine if we're in a Rails app context or standalone gem
          base_path = defined?(Rails) && Rails.respond_to?(:root) ? Rails.root : Pathname.new(Dir.pwd)

          full_dsl_path = base_path.join(paths[:dsl])
          full_function_path = paths[:function] ? base_path.join(paths[:function]) : nil

          # Create directories
          FileUtils.mkdir_p(full_dsl_path.dirname)
          FileUtils.mkdir_p(full_function_path.dirname) if full_function_path

          # Generate content
          dsl_content = generate_dsl(form)
          # Use function_body (required field)
          function_content = form.function_body

          # Write files
          File.write(full_dsl_path, dsl_content)
          File.write(full_function_path, function_content) if full_function_path

          # Register in TriggerRegistry
          definition = {
            name: form.trigger_name,
            table_name: form.table_name,
            events: form.events.reject(&:blank?),
            function_name: form.function_name,
            version: form.version,
            enabled: form.enabled,
            environments: form.environments.reject(&:blank?),
            condition: form.condition
          }

          registry = TriggerRegistry.create!(
            trigger_name: form.trigger_name,
            table_name: form.table_name,
            version: form.version,
            enabled: form.enabled,
            source: "generated",
            environment: form.environments.reject(&:blank?).join(","),
            definition: definition.to_json,
            function_body: function_content,
            condition: form.condition,
            checksum: calculate_checksum(definition)
          )

          {
            success: true,
            registry_id: registry.id,
            dsl_path: paths[:dsl],
            function_path: paths[:function],
            metadata: {
              trigger_name: form.trigger_name,
              table_name: form.table_name,
              events: form.events.reject(&:blank?),
              files_created: [paths[:dsl], paths[:function]].compact
            }
          }
        rescue => e
          Rails.logger.error("Trigger generation failed: #{e.message}") if defined?(Rails)
          Rails.logger.error(e.backtrace.join("\n")) if defined?(Rails)

          {
            success: false,
            error: e.message
          }
        end

        private

        def calculate_checksum(definition)
          Digest::SHA256.hexdigest(definition.to_json)
        end
      end
    end
  end
end
